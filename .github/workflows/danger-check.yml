name: Danger Check

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  danger-analysis:
    name: Run Danger Analysis
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for proper git diff

      - name: Fetch base branch
        run: |
          git fetch origin ${{ github.base_ref }}:${{ github.base_ref }}

      - name: Install dependencies
        run: |
          # Install jq if not already available
          if ! command -v jq &> /dev/null; then
            sudo apt-get update
            sudo apt-get install -y jq
          fi

      - name: Run Danger Analysis
        id: danger
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTIONS: true
          LOCAL_MODE: false
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          # Make the script executable
          chmod +x run-danger.sh

          # Run the danger system
          ./run-danger.sh ${{ github.base_ref }}

          echo "analysis_exit_code=$?" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Upload analysis results
        id: upload-results
        uses: actions/upload-artifact@v4
        with:
          name: danger-results
          path: Danger/danger-results.json
          retention-days: 7

      - name: Format and Post PR Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GEN_TOKEN }}
          script: |
            const fs = require('fs');

            // Read the results.json file
            const resultsPath = 'Danger/danger-results.json';
            const results = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));

            // Extract issues
            const errors = results.results.errors || [];
            const warnings = results.results.warnings || [];
            const infos = results.results.infos || [];

            // Build the comment
            let comment = '## üîç Danger Analysis Results\n\n';

            // Summary
            comment += `**Summary:** ${results.summary.error_count} errors, ${results.summary.warning_count} warnings, ${results.summary.info_count} info messages\n\n`;

            // Status
            if (results.summary.passed) {
              comment += '‚úÖ **Status:** All checks passed!\n\n';
            } else {
              comment += '‚ùå **Status:** Issues found that need attention\n\n';
            }

            // Errors (always show all)
            if (errors.length > 0) {
              comment += '### üö® Errors\n\n';
              errors.forEach((error, index) => {
                comment += `**${index + 1}. ${error.rule_name.trim()}** (${error.rule_id})\n`;
                comment += `   üìÅ File: \`${error.file.trim()}\``;
                if (error.line > 0) {
                  comment += ` (line ${error.line})`;
                }
                comment += '\n';
                comment += `   üí¨ ${error.message.trim()}\n`;
                if (error.details && error.details.trim()) {
                  comment += `   üìù Details: ${error.details.trim()}\n`;
                }
                comment += '\n';
              });
            }

            // Warnings and Infos (limit to 20 combined)
            const nonErrors = [...warnings, ...infos];
            const totalNonErrors = warnings.length + infos.length;
            const showLimit = 20;
            const truncated = totalNonErrors > showLimit;
            const itemsToShow = truncated ? nonErrors.slice(0, showLimit) : nonErrors;

            // Warnings
            const warningsToShow = itemsToShow.filter(item => warnings.includes(item));
            if (warningsToShow.length > 0) {
              comment += '### ‚ö†Ô∏è Warnings\n\n';
              warningsToShow.forEach((warning, index) => {
                comment += `**${index + 1}. ${warning.rule_name.trim()}** (${warning.rule_id})\n`;
                comment += `   üìÅ File: \`${warning.file.trim()}\``;
                if (warning.line > 0) {
                  comment += ` (line ${warning.line})`;
                }
                comment += '\n';
                comment += `   üí¨ ${warning.message.trim()}\n`;
                if (warning.details && warning.details.trim()) {
                  comment += `   üìù Details: ${warning.details.trim()}\n`;
                }
                comment += '\n';
              });
            }

            // Infos
            const infosToShow = itemsToShow.filter(item => infos.includes(item));
            if (infosToShow.length > 0) {
              comment += '### ‚ÑπÔ∏è Info\n\n';
              infosToShow.forEach((info, index) => {
                comment += `**${index + 1}. ${info.rule_name.trim()}** (${info.rule_id})\n`;
                comment += `   üìÅ File: \`${info.file.trim()}\``;
                if (info.line > 0) {
                  comment += ` (line ${info.line})`;
                }
                comment += '\n';
                comment += `   üí¨ ${info.message.trim()}\n`;
                if (info.details && info.details.trim()) {
                  comment += `   üìù Details: ${info.details.trim()}\n`;
                }
                comment += '\n';
              });
            }

            // If truncated, add a note and link
            if (truncated) {
              const hiddenCount = totalNonErrors - showLimit;
              comment += `\n### ‚ö° Additional Issues\n\n`;
              comment += `Showing first ${showLimit} of ${totalNonErrors} warnings and info messages. `;
              comment += `**${hiddenCount} additional issues** are available in the full report.\n\n`;
              
              // Link to the artifact
              const artifactUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
              comment += `üìÑ [View full results in workflow artifacts](${artifactUrl})\n`;
            }

            // Add timestamp
            comment += `\n---\n`;
            comment += `üïê Analysis performed at: ${results.timestamp}\n`;
            comment += `üîç Commit: \`${results.commit.substring(0, 7)}\`\n`;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('üîç Danger Analysis Results')
            );

            // Create or update comment
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }

      - name: Check if PR should be blocked
        if: steps.danger.outputs.analysis_exit_code != '0'
        run: |
          echo "‚ùå Danger checks failed! Please fix the issues before merging."
          exit 1
